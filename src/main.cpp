/***************************************************************
Emmanuel Addey
KRONOS V.2
10/5/2024

Wiring
IO Pin  Variable    Type    IO Mode   Pull-up   Hardware
---------------------------------------------------------
17      SDA0_Pin    Digital   I2C       Yes     SDA Serial
18      SCL0_Pin    Digital   I2C       Yes     SCL Serial
9       HALL1       Analog    Input     N/A     Hall Effect Sensor
10      HALL2       Analog    Input     N/A     Hall Effect Sensor
35                  Digital   FastLED   N/A     Button RGBs
48                  Digital   FastLED   N/A     RGB Array

I2C Address
---------------------------------------------------------
OLED SSD1306 0x3C
ADS1_0x49
ADS2_0x48
***************************************************************/

#include <Arduino.h>
#include <Wire.h>
#include <FastLED.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Wire.h>
#include <BleKeyboard.h>
#include <AS5600.h>
#include <String.h>
#include <Adafruit_ADS1X15.h>

// Data Pins
#define DATA_PIN 48 // ARGB DATA PIN 
#define DATA_PIN2 35 // ARGB DATA PIN 2
#define SDA0_Pin 17  // ESP32 SDA PIN
#define SCL0_Pin 18   // ESP32 SCL PIN
#define SCRLBUTTON 3 // BUTTON PIN

// For ARGB ARRAY (75 LEDS)
#define NUM_LEDS 75 // ***Delete this when new board is made
#define ARGB_CHIPSET WS2812B
static uint8_t hue = 0;
static uint8_t hue2 = 100;
CRGB leds[NUM_LEDS];

// For BUTTON ARRAY (6 LEDS *5 WORKING)
#define NUM_LEDS2 6 
CRGB leds2[NUM_LEDS2];

// Hall Effect Rotary Encoder
AS5600 as5600;   //  use default Wire
static uint32_t newPosition = 0;
static uint32_t oldPosition = 0;
int rpm;
int lastEncoderValue = 0;
int currentEncoderValue = 0;


// Hall Effect Button Control (ADC)
Adafruit_ADS1115 ads1;
Adafruit_ADS1115 ads2;

#define HALL1 0 // HALL EFFECT SENSOR 1 GPIO
#define HALL2 1 // HALL EFFECT SENSOR 2 GPIO
#define HALL3 2 // HALL EFFECT SENSOR 2 GPIO
#define HALL4 0 // HALL EFFECT SENSOR 2 GPIO
#define HALL5 1 // HALL EFFECT SENSOR 2 GPIO
#define HALL6 2 // HALL EFFECT SENSOR 2 GPIO

int hallsens = 3;
int currentHall = 1;

// Timer Function to set a timer 
class TimerX {
  private:
    unsigned long previousMillis = 0UL; 
    unsigned long currentMillis = 0UL;
    long interval = 1000UL;

  public:
    bool timerActive = false;
    TimerX(){

    } 


    void startTimer(){
      previousMillis = millis();
      timerActive = true;
    }

    void stopTimer(){
      timerActive = false;
    }

    bool checkTimer(){
      currentMillis = millis();
      return timerActive && (currentMillis - previousMillis >= interval); //will return true if timer is active and time has passed
    }

    void resetTimer(){
      previousMillis = millis();
    }

    void setIntervalSeconds(long interval){
      this -> interval = interval * 1000;
    }

    void setIntervalMinutes(long interval){
      this -> interval = interval * 60 * 1000;
    }
    long getInterval(){
      return interval;
    }

    long getTimeLeft(){
      unsigned long elapsedTime = (millis() - previousMillis) / 1000;
      long timeLeft = interval - elapsedTime;
      return timeLeft;
    }

    unsigned long getPreviousMillis(){
      return previousMillis;
    }

    unsigned long getCurrentMillis(){
      return currentMillis;
    }

};
//
class Button
{
  private:
    uint8_t btn;
    uint16_t state;
  public:
    void begin() {
      state = 0;
    }
  bool debounce(bool output) {
    static uint16_t state = 0;
    state = (state << 1) | output | 0xfe00;
    return (state == 0xfe01);
  }
};

Button hall1;
Button hall2;
Button hall3;
Button hallall;

bool hallScanC1 = 0;
bool hallScanC2 = 0;
bool hallScanC3 = 0;

class ADCHALLX {
  private:
    static const int averagingSamples =  2;
    int readIndex = 0;
    int total = 0; // used in hallReadClean
    int average = 0; // used in hallReadClean
    int precision = 1; // precison 1 = 128 2= 256 3 = 512 4 = 1024 5 = 2048
    int trigPoint = 0;
    int16_t value; 
    int readings[averagingSamples]; // used in hallReadClean
    int minVal=4095;
    int maxVal=0;
    int adcsel=0;
 
    // check if AS5600 library is included
    #if __has_include (<AS5600.h>)
      const bool USE_AS5600 = 1;
    #else
      const bool USE_AS5600 = 0;
    #endif

  public:
    byte channel;
    int option=1;
    ADCHALLX(byte channel) {
      this->channel = channel;
    }


bool setI2C(String CONN){
    if (CONN == "GND"){

        if (!ads1.begin(0x48)){
            log_e("Failed to initialize ADS1115 at 0x49");
            for(;;);
        }
        adcsel = 0;
        return 1;
    } else if (CONN == "VDD"){
       
        if (!ads2.begin(0x49)) {
            log_e("Failed to initialize ADS1115 at 0x48");
            for(;;);
        }
        adcsel  = 1;
        return 1;
    } else if (CONN == "SDA"){
        adcsel = 2;
        return 1;
    } else if (CONN == "SCL"){
        adcsel = 3;
        return 1;
    }
}
    int16_t readADX(){
      if(adcsel == 0){
        return ads1.readADC_SingleEnded(channel);
      }
      else if(adcsel == 1){
        return ads2.readADC_SingleEnded(channel);
      }
      return 0;
    }
    // Return raw sensor value from 0 to 4095
    int hallRead(){
      value = readADX();
      return value;
    }

    // Set the min and max hall analog values
    int hallCal(){
      // record hall analog max value
      value = readADX();
      if (value > maxVal) {
        maxVal = value;
      }
      // record hall analog min value
      if (value < minVal) {
        minVal = value;
      }
      return value;
    }

    // set hall precision variable (128, 256, 512, 1024, 2048)
    void setSens(int mutliplier){
      precision = mutliplier;
    }

    // return hall analog value that has been proper precision **PREFFERED FOR RAW OUTPUT
    int hallReadCal(){
      int mapMax;
      mapMax = precision * 128;
      value = readADX()-0; // record hall analog value
      value = constrain(value, minVal, maxVal); // in case the hall analog value is outside the range seen during calibration67
      value = map(value, minVal, maxVal, 0, mapMax); // map the hall analog value to a range from 0 to 1000
      return value;
      Serial.println(value);
    }

    // return hall analog value with calibration and noise reduction !!SLOW!!
    int hallReadClean(){
      total = total - readings[readIndex];
      readings[readIndex] = hallReadCal(); // read from the hall analog:
      total = total + readings[readIndex]; // add the reading to the total:
      readIndex = readIndex + 1; // advance to the next position in the array:
    // if we're at the end of the array...
      if (readIndex >= averagingSamples) {
        // ...wrap around to the beginning:
        readIndex = 0;
        average = total / averagingSamples;
      }
    delay(1);
    return average;
    }

    // set hall trigger point
    int hallSetTrigRotary(){
      int hallTrigMax = (precision * 128);
      // check if AS5600 library is included ((determined by ))
      if (USE_AS5600){ 
        int hallSetCurrent = as5600.rawAngle();
        map(hallSetCurrent, 0, 4056, 0, hallTrigMax);
        trigPoint = hallSetCurrent / 2;
        return trigPoint;
      }
      else{
        trigPoint = 0;
        return trigPoint;
      }
    }

    bool checkHallTrig(int option){
      switch (option) {
        case 0:
            return hallReadCal() < trigPoint;
        break;

        case 1:
            return hallRead() > 10000;
        break;

        default:
          return false;
        break;
        }
      }
};

ADCHALLX h[] = {ADCHALLX(HALL1), ADCHALLX(HALL2), ADCHALLX(HALL3), ADCHALLX(HALL4) ,ADCHALLX(HALL5) ,ADCHALLX(HALL6)};
bool hallcalibrated = 0;

// OLED Display
#define SCREEN_WIDTH 128 // OLED width,  in pixels
#define SCREEN_HEIGHT 64 // OLED height, in pixels
Adafruit_SSD1306 oled(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);
int displayLayer =0;
String displayText = "Press Key 1"; // 
String displayText2 = "Keep Pressing";

// Logo Bitmap for OLED Display
const unsigned char myBitmap [] PROGMEM = 
{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xe0, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x07, 
	0xff, 0xff, 0xe0, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x0f, 
	0xff, 0xff, 0xc0, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x0f, 
	0xff, 0xff, 0xc0, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x1f, 
	0xff, 0xff, 0xc0, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x80, 0x00, 0x00, 0x3f, 
	0xff, 0xff, 0xc0, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x80, 0x00, 0x00, 0x7f, 
	0xff, 0xff, 0x80, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
	0xff, 0xff, 0x80, 0x00, 0x3f, 0xc0, 0x00, 0x01, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0x80, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xff, 0xff, 0x80, 0x00, 0x3f, 0x80, 0x00, 0x07, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 
	0xff, 0xff, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x07, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 
	0xff, 0xff, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 
	0xff, 0xff, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x1f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 
	0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 
	0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x07, 0xff, 0xff, 
	0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x0f, 0xff, 0xff, 
	0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x1f, 0xff, 0xff, 
	0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x3f, 0xff, 0xff, 
	0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xff, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 
	0xff, 0xf0, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 
	0xff, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 
	0xff, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 
	0xff, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 
	0xff, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 
	0xff, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 
	0xff, 0xe0, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 
	0xff, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 
	0xff, 0xc0, 0x00, 0x08, 0x00, 0x01, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 
	0xff, 0xc0, 0x00, 0x18, 0x00, 0x01, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 
	0xff, 0xc0, 0x00, 0x1c, 0x00, 0x00, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 
	0xff, 0x80, 0x00, 0x1c, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 
	0xff, 0x80, 0x00, 0x1e, 0x00, 0x00, 0x7f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 
	0xff, 0x80, 0x00, 0x3e, 0x00, 0x00, 0x7f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 
	0xff, 0x80, 0x00, 0x3e, 0x00, 0x00, 0x3f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 
	0xff, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x3f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 
	0xff, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 
	0xff, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x1f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 
	0xff, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x1f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 
	0xfe, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 
	0xfe, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 
	0xfe, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xfc, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xfc, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x04, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xfc, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xfc, 0x00, 0x01, 0xff, 0xf0, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xf8, 0x00, 0x01, 0xff, 0xf8, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x3f, 0xff, 0xff, 
	0xf8, 0x00, 0x01, 0xff, 0xf8, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x3f, 0xff, 0xff, 
	0xf8, 0x00, 0x03, 0xff, 0xfc, 0x00, 0x00, 0x80, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x3f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
 
//Bluetooth keyboard library stuff
BleKeyboard bleKeyboard; 

// Delay Control
unsigned long previousMillis = 0UL;
const long interval = 500UL;

// Timer
bool blink= 0;
unsigned long startTime;
int timerDuration = 25 * 60; // 25 minutes in seconds

// Cycletime benchmark
long duration;

// Layer control 
int currentLayer = 0;
const int MAX_LAYERS = 3;
int tempcurrentLayer= 0 ;

// Task Handler

/*******************************************************************END OF DEFINITIONS AND DECLERATIONS*****************************************************/


void updateDisplay(int timeLeft) {
  oled.clearDisplay(); // clear display
  switch (displayLayer) {
  // boot up screen
  case 0:
    oled.clearDisplay(); // clear display
    oled.setTextSize(2);         // set text size
    oled.setTextColor(WHITE);    // set text color
    oled.drawBitmap(0, 0, myBitmap, 128, 64, WHITE);
    oled.display();
    break;
  // calibration screen
  case 1:
    oled.clearDisplay(); // clear display
    oled.setTextSize (2);         // set text size
    oled.setTextColor(WHITE);    // set text color
    oled.setCursor(0, 2);       // set position to display (x, y)
    oled.println(displayText);
    oled.println(h[currentHall].hallCal());
    oled.display(); 
    break;
  
  // maintenance mode screen 2
  case 2:
    oled.setTextSize(1);         // set text size
    oled.setTextColor(WHITE);    // set text color
    oled.setCursor(0, 2);       // set position to display (x, y)
    oled.print("Rotary:");
    oled.print("BLEKEY:");
    oled.println(bleKeyboard.isConnected());
    oled.print("H1: "); oled.print(h[0].hallRead()); oled.print(" H2: "); oled.println(h[1].hallRead()); 
    oled.print("H3: "); oled.print(h[2].hallRead()); oled.print(" H4: "); oled.println(h[3].hallRead()); 
    oled.print("H5: "); oled.print(h[4].hallRead()); oled.print(" H6: "); oled.println(h[5].hallRead()); 
    oled.print("TMPL"); oled.print(tempcurrentLayer);
    oled.print("RAWANG: "); oled.println(as5600.rawAngle());
    oled.print("Cycletime: ");
    oled.println(duration);
    oled.print(" CAL: "); oled.print(hallcalibrated);
    oled.display();
 
    break;
  case 3:
    oled.clearDisplay();
    oled.setTextSize(2);
    oled.setTextColor(WHITE);
    oled.setCursor(0, 0);
    oled.print("Time: ");
    oled.print(timeLeft / 60);
    oled.print(":");
    oled.print(timeLeft % 60);
    oled.setCursor(0, 32);
    oled.print("Layer: ");
    oled.print(currentLayer);
    oled.display();
    break;
  default:
    oled.display();
    break;
  }
  }
void calibrateHallButtons() {
  hallcalibrated = 0;
  int numHalls = 6;
  int startTimer = 0;
  int timerSet = 500;//millis
  bool calibrationComplete = false;
  bool arrayCalibrationComplete = false;
  currentHall = 0;
  displayLayer=1;

  while(currentHall <= (numHalls-1)) {
    calibrationComplete = 0;
    while(!calibrationComplete) {
 
      while(h[currentHall].checkHallTrig(1) == 0) {
        displayText = "PRESS HALL " + String(currentHall);
        updateDisplay(0);
      }
      startTimer = millis();
      arrayCalibrationComplete = 0;
      while((h[currentHall].checkHallTrig(1) == 1) && (!arrayCalibrationComplete)) {
        h[currentHall].hallCal();
        if ((startTimer + (timerSet / 2)) > millis()) {
          displayText = "FULLY PRESS";
          updateDisplay(0); 
        }
        else if ((startTimer + (timerSet/2)+(timerSet / 4)) > millis()) {
          displayText = "ALMOST THERE";
          updateDisplay(0);
        }
        else if((startTimer + timerSet) < millis()) {
          displayText = "HALL " + String(currentHall) + " CALIBRATED";
          updateDisplay(0);
          delay(1500);
          arrayCalibrationComplete = 1;
          calibrationComplete = 1;
          currentHall++;
        }
        updateDisplay(0);
      }
    }  
  }
hallcalibrated = 1;
}

void handleEncoder() {
  currentEncoderValue = as5600.rawAngle();
}

void solidColor(CRGB* leds, int numLeds, CRGB color) {
  for(int i = 0; i < numLeds; i++) {
    leds[i] = color;
    FastLED.show();
  }
  FastLED.show();
}
void setup() { 
  Serial.begin (115200);
  Serial.setDebugOutput(true);
  log_e("Serial Initialized!");

  Wire.begin(SCL0_Pin, SDA0_Pin );
  log_e("Wire Initialized!");

  Serial.println("Starting KRONOS!");
  ads1.setGain(GAIN_TWOTHIRDS);  // 2/3x gain +/- 6.144V  1 bit = 3mV (default)
  ads2.setGain(GAIN_TWOTHIRDS);  // 2/3x gain +/- 6.144V  1 bit = 3mV (default)
  h[0].setI2C("GND");
  log_e("H1 Initialized!");
  h[1].setI2C("GND");
  log_e("H2 Initialized!");
  h[2].setI2C("GND");
  log_e("H3 Initialized!");
  h[3].setI2C("VDD");
  log_e("H4 Initialized!");
  h[4].setI2C("VDD");
  log_e("H5 Initialized!");
  h[5].setI2C("VDD");
  log_e("H6 Initialized!");


  if (!oled.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("failed to start SSD1306 OLED"));
    while (1);
  }
  log_e("OLED Intialized!");

  //Fast LED
	FastLED.addLeds<ARGB_CHIPSET,DATA_PIN,RGB>(leds,NUM_LEDS);
	FastLED.addLeds<ARGB_CHIPSET,DATA_PIN2,RGB>(leds2,NUM_LEDS2);
  FastLED.clear();
  FastLED.setBrightness(30);
  solidColor(leds,NUM_LEDS,CRGB::White);
  FastLED.show();
  log_e("FASTLED Intialized!");

  // calibration only at boot up **(add calibration prompt or use NVS storage to skip this if already done)
  calibrateHallButtons();
  log_e("Calibration Complete!");

  Serial.println("KRNOS INITIALIZED...");
}
void loop() { 
  long start = micros();//KEEP AT BEGINNING OF LOOP, FOR TIMER
  handleEncoder();
  displayLayer=2;
  updateDisplay(0);
  duration = micros() - start; // KEEP AT END, FOR TIMER
}
